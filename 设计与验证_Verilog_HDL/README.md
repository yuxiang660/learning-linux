# 序
《设计与验证：Verilog HDL》读书笔记
## 环境搭建
* [例子1](./code/hello)
* [例子2](./code/wave)

# HDL设计方法简介
## 设计方法的变迁
* 数字设计系统方法演变
   * 早期，使用卡诺图简化后，通过面包板系统验证设计
   * 中期，借助EDA工具通过原理图描述数字系统，通过EDA工具元件库中的元件对原理图进行仿真并分析其性能
   * 后期，由于原理图不利于移植且维护费力，硬件描述语言(HDL)应运而生

* HDL语言描述数字电路系统的不同层次
   * 算法
   * 系统级(System Level)
   * 功能模块级(Function Model Level)
   * 行为级(Behavior Level)
   * 寄存器传输级(RTL, Register Transfer Level)
   * 门级(Gate Level)
   * 开关级(Switch Level)

* EDA工具的目的
   * 层次越高，越容易编写和维护，EDA工具的作用就是将高层次的HDL电路描述通过逻辑综合(Synthesize)，分析到门级
   * EDA综合工具能将高层次的HDL语言、原理图等设计描述翻译成由与、或、非门等基本逻辑单元组成的门级连接(网表)
   * 并根据设计目标与要求(约束条件)优化生成的逻辑连接，输出门级网表文件

## Verilog的语言特点
### HDL与原理图
* 两种描述电路的方法
   * HDL
   * 原理图
      * 优点：直观
      * 缺点：难以重用
* 两种辅助设计方法
   * 波形输入
      * EDA软件根据输入波形和输入波形，自动设计或仿真
   * 状态机输入
      * 设计者只需画出状态转移图，EDA软件就能生成相应的HDL代码或原理图

### 不同层次的HDL语言
![hdl](./pictures/hdl.png)

### Verilog和C语言
* 最大区别
   * 互连(connectivity)
      * Verilog的wire型变量能描述网线的互连，C没有互连的概念
   * 并发(concurrency)
      * Verilog可以有效地描述并行的硬件系统，C语言本质上是串行的
   * 时间(time)
      * Verilog定义了绝对和相对的时间度量，在仿真时可以通过时间度量与周期关系描述信号之间的时间关系，C语言没有严格的时间概念，程序运行时长取决于处理器本身
* HDL语言的本质
   * HDL的评判标准时其描述并实现的硬件电路的性能(包括面积和速度两个方面)
   * 片面追求代码的整洁、简短时错误的
   * 首先需要对硬件的结构与连接了解十分透彻，再用适当的HDL语言将其表达出来

### Verilog与C的结合
* Verilog由于要描述硬件，它的抽象要比C语言差一些
* Verilog可以通过PLI(编程语言接口)将Verilog和C联系起来，Verilog负责描述电路，而C语言可以辅助验证，以使验证方式更加灵活

## HDL的设计与验证流程
* HDL的设计与仿真流程如下：<br>
   ![hdl_design_verification](./pictures/hdl_design_verification.png)
   * 系统与功能模块级
      * 多采用高级语言描述，如：C/C++，System C和System Verilog
      * 主要目标使对系统的整体功能和性能指标进行衡量
      * 系统级描述完成后，应划分模块，定义接口，考虑时序约束，开始功能模块级
   * 行为级描述测试激励
      * 主要使用Verilog和VHDL
      * 此阶段必须明确每个模块间的所有接口和边界
      * 常用行为级描述方式编写测试激励
   * 寄存器传输级
      * 主要使用Verilog和VHDL
      * 通过描述寄存器到寄存器之间的逻辑功能描述电路的HDL层次
      * 可以直接用综合工具将其综合为门级网表
   * 对RTL级描述进行功能仿真
      * 目的使验证RTL级描述是否与设计意图一致
      * 为了提高效率，功能仿真的测试激励一般使用行为级的HDL语言描述
   * 逻辑综合(使用RTL级EDA工具)
      * 将RTL级HDL语言翻译成由与或非等基本逻辑单元组成的门级连接(网表)，并根据设计目标与要求(约束条件)优化所生成的逻辑连接、输出门级网表文件
   * 门级
      * 特点是整个设计用逻辑门实现，通过逻辑门的组合显化描述设计的引脚、功能和时钟周期等信息
   * 综合后门级仿真
      * 在仿真时，把综合生成的标准延时文件反标注到综合仿真模型中去，可估计门延时所带来的影响
      * 综合后仿真虽然比功能仿真要精确一些，但只能估算门延时，不能估算线延时，仿真结果与布线后的实际情况还有一定的差距，并不十分准确
      * 这种仿真的目的在于检查综合后结果是否与原设计一致
   * 布局规划与布局布线
   * 布局布线后的时序仿真与验证
      * 将最终布局规划或布局布线的延时信息反标注到设计网表中进行的仿真就叫时序仿真或布局规划与布局布线后仿真，简称后仿真
      * 时序仿真的主要目的在于发现时序违规(Timing Violation)，即不满足时序约束条件或者器件固有时序规则(建立时间、保持时间等)的情况

# Verilog语言基础
## Top-Down和Bottom-Up
* Verilog对两种设计方法都支持

## Verilog的3种描述方法
### 实例
* 电路描述<br>
   ![hello_verilog](./pictures/hello_verilog.png)
   * 选择器MUX2在2比特输入A_in[1:0]和B_in[1:0]选择一个
   * 2-4译码器将2比特输入解析成4个信号，一个时刻只有一个信号是1
   * 将4个信号分成前后两组取异或
   * 异或结果通过寄存器输出给`A_xor_out`和`B_xor_out`
* 虽然描述的时候是从左到右描述的，但是这些电路都是并行工作的，没有先后顺序关系
* [Module](./code/hello_verilog/hello_vlog.v)
   * 先声明后行为
* [TestBench](./code/hello_verilog/tb.v)
   * 声明
   * 实例化module
   * 行为
      * 时钟
      * 初始化输入引脚
      * 结束仿真`$finish`

### 3种描述方法
* 数据流描述
   * 采用`assign`语句(连续赋值语句)
* 行为描述
   * 使用`always`或`initial`语句块，其中出现的语句被称为过程赋值语句
* 结构化描述
   * 实例化已有的功能模块
      * Module实例化：实例化已有的module
      * 门实例化：实例化基本的门电路原语
      * 用户定义原语(UDP)实例化：实例化用户定义的原语

## 模块和端口
* 通常情况下一个Verilog文件只放一个module定义，而且要使文件名称与module名称一致
* module的结构如下：
   ```
   module 模块名称(端口列表);
   // 声明:
      input, output, inout,
      reg, wire, parameter,
      function, task, ...
   // 语句:
      initial 语句
      always 语句
      module 实例化
      门实例化
      用户定义原语(UDP)实例化
      连续赋值(Continuous assignment)
   ```
   * module的端口
      * 仿真平台的顶层`tb`是一个封闭系统，不含端口
      * module的`input`默认定义为`wire`类型
      * module的`output`可以使wire类型，也可以使`reg`类型
      * module的`inout`是双向的，一般将其设定为`tri`类型，表示其右多个驱动元，如无驱动则为三态
   * 出现在一个module中的语句，互相之间没有任何顺序关系

## 编译指令
* 常用的编译指令
   ```
   `timescale;
   `define, `undef;
   `ifdef, `else, `endif;
   `include;
   `resetall;
   ```
* 编译指令规则
   * 编译器一旦遇到某个编译指令，则该指令在整个编译过程中有效，知道编译器遇到另一个相同的编译指令为止
### `timescale
* timescale编译指令如果在模块外部出现，会影响后面模块中的所有延时值，知道遇到下一个timescale或者resetall
* 以延时`#1.16`为例子，分析不同timescale下的真实延时
   * `timescale 1ns/100ps
      * 最小时间颗粒度是0.1ns
      * 真实延时是1.16ns的十分位四舍五入：1.2ns
   * `timescale 1ns/10ps
      * 最小时间颗粒度是0.01ns
      * 真实延时是1.16ns的百分位四舍五入：1.16ns

### `define
* 用于定义宏
   ```verilog
   // 利用宏定义一个宽度位16的reg类型数据Data
   `define BUS_WIDTH 16
   reg [`BUS_WIDTH-1 : 0] Data;
   ```
* 在一个文件中出现的define可以被多个文件使用(这是define和parameter定义的最大区别)，直到遇到undef指令为止

### `include
* 嵌入某个文件中的内如
   * ``include "HEADFILE.h`，在编译的时候，文件中的内容会完全替换这一行

### `resetall
* 将其他编译指令重新设置位缺省值

## 逻辑值和常量

### 逻辑值
* Verilog里有4种逻辑，除了1和0外，还有XZ(不区分大小写)
   * "X"
      * 表示状态未知
      * 当用作条件判断时(在casex或casez)表示不关心
   * "Z"
      * 表示高阻态，通常用来对三态总线进行建模<br>
      ![1_0_z](./pictures/1_0_z.png)

### 常量
* 常量的3种类型
   * 整数型
      * `8'haa` - 8位16进制
      * `6'o33` - 6位8进制
      * `4'b1011` - 4位2进制
      * `3'd7` - 3位十进制
      * 遇到X，在16进制中表示4个X，在八进制中表示3个X
   * 实数型
   * 字符串型
* [例子](./code/type/types.v)

### 变量类型
* Verilog有两种变量类型
   * 线网型`wire`：表示电路间的物理连线
      * 凡是在assign语句中赋值的变量，一定是线网变量
   * 寄存器型`reg`：Verilog中的一个抽象存储单元
      * 凡是在always或initial语句中赋值的变量，一定是寄存器变量

### 网线类型
* 网线类型包括以下几种子类型，它们具有网线的共性
   * wire, tri
      * 表示电路间的物理连线，tri主要用于多驱动源建模
   * wor, trior
      * 表示该连线具有“线或”功能
   * wand, triand
      * 表示该连线具有“线与”功能
   * trireg
      * 表示该连线具有总线保持功能
   * tri0, tri1
      * 表示当无驱动时，连线状态为1(tri1)和0(tri0)
   * supply1, supply0
      * 分别表示电源和地信号
* 除了trireg未初始化时值为X以外，其余子类型未初始化时的值均为Z
* 线网类型主要用在连续赋值语句中，并可作为模块之间的互连信号

### 寄存器类型
* 寄存器类型的变量通常要占据一个仿真内存空间
   * reg
      * 可以时一位、多为或者二维数组
   * integer
      * 整数型数据
      * 存储一个至少32位的整数
   * time
      * 时间类型
      * 存储一个至少64位的时间值
   * real, realtime
      * 实数和实数时间寄存器
* 例子：reg类型定义二位寄存器数组，用于描述存储器Memory
   * `reg [3:0] MEMABC [0:7]` // 定义一个存储器，地址为0~7，每个存储单元都是4bit
   * 不能对存储器中的存储单元进行位选择或部分选择，只能每个单元整体赋值：`MEMABC[1] = 4'b0101;`
   * 除非使用`$readmemb`或`$readmemh`系统任务从文件中读入整个或部分存储器数据，Verilog不存在一条语句可以对整个存储器赋值

### 变量的物理含义
* 在仿真工具进行仿真时
   * 寄存器类型的变量是占用仿真环境的物理内存
   * 线网变量是不占用仿真内存的，它的值由当前所有驱动该线网的其他变量(可以是寄存器变量或线网变量)决定

### 驱动和赋值
* 驱动
   * 线网是被驱动的，该值不被存储，在任意一个仿真步进上都需要重新计算
* 赋值
   * 寄存器是被赋值的，且该值将在仿真过程中被保存，直到再次对该变量进行赋值
* 以异或门电路举例
   * 连续赋值语句，在任意一个仿真时刻，当前时刻eq0和eq1相异或的结果决定了1ns以后线网变量A_xor_wire的值。这个驱动时一直存在的，因此称为连续驱动
   ```verilog
   wire A_xor_wire;
   assign #1 A_xor_wire = eq0 ^eq1;
   ````
   * `always`语句，只有在某些时刻，该语句才会被执行，将eq0和eq1赋值的结果延时1ns以后赋值给A_xor_wire。而在其他时刻，A_xor_wire变量将保持不变。因此从仿真语义上讲，需要一个存储单元，来保存A_xor_wire变量的中间值。
   ```verilog
   reg A_xor_wire;
   always @ (eq0 or eq1)
      A_xor_wire = #1 eq0 ^ eq1;
   ```
   * 不管采用哪种方式，其对应的硬件电路都是完全相同的组合逻辑电路。第二种描述，虽然在语法上定义了reg类型，但是并没有被实现为硬件上的触发器(flip-flop)
   * 有时reg型变量仅仅在仿真语义上被理解为寄存器概念，而在实际电路实现时却被实现为纯组合逻辑

## 参数
* 参数是一种常量，通常出现在module内部(局部定义)，常被用于定义状态机的状态、数据位宽和延时大小等，例如：
   ```verilog
   parameter and_delay = 2;
   parameter xor_delay = 4;
   ```

## Verilog中的并发与顺序
* 在Verilog中，所有语句都是并行发生的
* 在语句块(always和initial)内部可以存在两种语句组：
   * `begin...end;` 顺序语句组
      * 可综合
   * `for...join;` 并行语句组
      * 不可综合

## 操作数、操作符和表达式
### 操作符
![verilog_op](./pictures/verilog_op.png)

![op_priority](./pictures/op_priority.png)
* 按位操作符
   * `m ~^ n` 或 `m ^~ n` - 将m的每个比特与n的相应比特相异或非
* 归约操作符
   * `~^m` 或 `^~m` - 将m中所有比特相异或非(1比特结果)
* 相等操作符
   * `==` - m和n相等吗？(1-bit正确/错误结果，仅比较逻辑1和0)
* 全等操作符
   * `===` - m和n全等吗？(1-bit正确/错误结果，比较逻辑0，1，x和z)
* 连接赋值操作符
   * `{m,n}` - 将m和n连接起来，产生更大的向量
   * `{n{m}}` - 将m重复n次

### 有符号数和无符号数
```
reg[4:0] Opreg; //一个5位的reg型变量，存储无符号数
integer Opint; //一个32位的integer型变量，存储有符号数

Opreg = -4'd12 / 4; //Opreg被赋值为29 (-3的五比特补码)
Opint = -4'd12 / 4; //Opint被赋值为1073741821，(-3的32位补码)

Opreg = -12/4; //Opreg被赋值为29
Opint = -12/4; //Opint被赋值为-3
```

## 系统任务和系统函数
* 显示任务
   * `$display`
   * [例子](./code/display)
* 文件输入/输出任务
   * 写入文件
      * `$fopen, $fdisplay, $fclose`
   * 从文件读出
      * `$readmemb, $readmemh`
* 其他系统任务和系统函数
   * 仿真控制任务
      * `$finish` - 使仿真器退出
      * `$stop` - 使仿真器挂起
   * 时序验证任务和仿真时间函数
      * `$setup` - 用来检测建立时间
      * `$hold` - 用来检测保持时间
      * `$time` - 系统函数，返回64位的模拟时间
   * 概率分布函数
      * `$random` - 系统函数，返回一个32位的有符号整型随机数
* 系统任务/系统函数只可以在仿真器中运行，综合工具和布线工具会将其忽略
