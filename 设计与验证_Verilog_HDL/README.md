# 序
《设计与验证：Verilog HDL》读书笔记
## 环境搭建
* [例子1](./code/hello)
* [例子2](./code/wave)

# HDL设计方法简介
## 设计方法的变迁
* 数字设计系统方法演变
   * 早期，使用卡诺图简化后，通过面包板系统验证设计
   * 中期，借助EDA工具通过原理图描述数字系统，通过EDA工具元件库中的元件对原理图进行仿真并分析其性能
   * 后期，由于原理图不利于移植且维护费力，硬件描述语言(HDL)应运而生

* HDL语言描述数字电路系统的不同层次
   * 算法
   * 系统级(System Level)
   * 功能模块级(Function Model Level)
   * 行为级(Behavior Level)
   * 寄存器传输级(RTL, Register Transfer Level)
   * 门级(Gate Level)
   * 开关级(Switch Level)

* EDA工具的目的
   * 层次越高，越容易编写和维护，EDA工具的作用就是将高层次的HDL电路描述通过逻辑综合(Synthesize)，分析到门级
   * EDA综合工具能将高层次的HDL语言、原理图等设计描述翻译成由与、或、非门等基本逻辑单元组成的门级连接(网表)
   * 并根据设计目标与要求(约束条件)优化生成的逻辑连接，输出门级网表文件

## Verilog的语言特点
### HDL与原理图
* 两种描述电路的方法
   * HDL
   * 原理图
      * 优点：直观
      * 缺点：难以重用
* 两种辅助设计方法
   * 波形输入
      * EDA软件根据输入波形和输入波形，自动设计或仿真
   * 状态机输入
      * 设计者只需画出状态转移图，EDA软件就能生成相应的HDL代码或原理图

### 不同层次的HDL语言
![hdl](./pictures/hdl.png)

### Verilog和C语言
* 最大区别
   * 互连(connectivity)
      * Verilog的wire型变量能描述网线的互连，C没有互连的概念
   * 并发(concurrency)
      * Verilog可以有效地描述并行的硬件系统，C语言本质上是串行的
   * 时间(time)
      * Verilog定义了绝对和相对的时间度量，在仿真时可以通过时间度量与周期关系描述信号之间的时间关系，C语言没有严格的时间概念，程序运行时长取决于处理器本身
* HDL语言的本质
   * HDL的评判标准时其描述并实现的硬件电路的性能(包括面积和速度两个方面)
   * 片面追求代码的整洁、简短时错误的
   * 首先需要对硬件的结构与连接了解十分透彻，再用适当的HDL语言将其表达出来

### Verilog与C的结合
* Verilog由于要描述硬件，它的抽象要比C语言差一些
* Verilog可以通过PLI(编程语言接口)将Verilog和C联系起来，Verilog负责描述电路，而C语言可以辅助验证，以使验证方式更加灵活

## HDL的设计与验证流程
* HDL的设计与仿真流程如下：<br>
   ![hdl_design_verification](./pictures/hdl_design_verification.png)
   * 系统与功能模块级
      * 多采用高级语言描述，如：C/C++，System C和System Verilog
      * 主要目标使对系统的整体功能和性能指标进行衡量
      * 系统级描述完成后，应划分模块，定义接口，考虑时序约束，开始功能模块级
   * 行为级描述测试激励
      * 主要使用Verilog和VHDL
      * 此阶段必须明确每个模块间的所有接口和边界
      * 常用行为级描述方式编写测试激励
   * 寄存器传输级
      * 主要使用Verilog和VHDL
      * 通过描述寄存器到寄存器之间的逻辑功能描述电路的HDL层次
      * 可以直接用综合工具将其综合为门级网表
   * 对RTL级描述进行功能仿真
      * 目的使验证RTL级描述是否与设计意图一致
      * 为了提高效率，功能仿真的测试激励一般使用行为级的HDL语言描述
   * 逻辑综合(使用RTL级EDA工具)
      * 将RTL级HDL语言翻译成由与或非等基本逻辑单元组成的门级连接(网表)，并根据设计目标与要求(约束条件)优化所生成的逻辑连接、输出门级网表文件
   * 门级
      * 特点是整个设计用逻辑门实现，通过逻辑门的组合显化描述设计的引脚、功能和时钟周期等信息
   * 综合后门级仿真
      * 在仿真时，把综合生成的标准延时文件反标注到综合仿真模型中去，可估计门延时所带来的影响
      * 综合后仿真虽然比功能仿真要精确一些，但只能估算门延时，不能估算线延时，仿真结果与布线后的实际情况还有一定的差距，并不十分准确
      * 这种仿真的目的在于检查综合后结果是否与原设计一致
   * 布局规划与布局布线
   * 布局布线后的时序仿真与验证
      * 将最终布局规划或布局布线的延时信息反标注到设计网表中进行的仿真就叫时序仿真或布局规划与布局布线后仿真，简称后仿真
      * 时序仿真的主要目的在于发现时序违规(Timing Violation)，即不满足时序约束条件或者器件固有时序规则(建立时间、保持时间等)的情况

# Verilog语言基础
## Top-Down和Bottom-Up
* Verilog对两种设计方法都支持

## Verilog的3种描述方法
### 实例
* 电路描述<br>
   ![hello_verilog](./pictures/hello_verilog.png)
   * 选择器MUX2在2比特输入A_in[1:0]和B_in[1:0]选择一个
   * 2-4译码器将2比特输入解析成4个信号，一个时刻只有一个信号是1
   * 将4个信号分成前后两组取异或
   * 异或结果通过寄存器输出给`A_xor_out`和`B_xor_out`
* 虽然描述的时候是从左到右描述的，但是这些电路都是并行工作的，没有先后顺序关系
* [Module](./code/hello_verilog/hello_vlog.v)
   * 先声明后行为
* [TestBench](./code/hello_verilog/tb.v)
   * 声明
   * 实例化module
   * 行为
      * 时钟
      * 初始化输入引脚
      * 结束仿真`$finish`

### 3种描述方法
* 数据流描述
   * 采用`assign`语句(连续赋值语句)
* 行为描述
   * 使用`always`或`initial`语句块，其中出现的语句被称为过程赋值语句
* 结构化描述
   * 实例化已有的功能模块
      * Module实例化：实例化已有的module
      * 门实例化：实例化基本的门电路原语
      * 用户定义原语(UDP)实例化：实例化用户定义的原语

## 模块和端口
* 通常情况下一个Verilog文件只放一个module定义，而且要使文件名称与module名称一致




