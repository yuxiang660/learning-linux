# 简介
《编译原理》(龙书）的读书笔记

# 引论

## 一个编译器的结构
* 分析analysis - 前端
   * 把源程序分解成多个组成要素
   * 使用此结构创建该源程序的一个中间表示
   * 把源程序存放在一个符号表(symbol table)的数据结构中
   * 符号表将和中间表示形式一起传送给综合部分
* 综合synthesis - 后端
   * 根据中间表示和符号表中的信息来构造用户期待的目标程序
* 详细步骤如下<br>
   ![compile_phase](./pictures/compile_phase.png)

### 词法分析 - lexical analysis
* 目的：生成token
* 对于每个词素，词法分析器产生`<token-name, attribute-value>`词法单元(token)作为输出
   * token-name是一个由语法分析步骤使用的抽象符号
   * attribute-value指向符号表中关于这个词法单元的条目
* `position = initial + rate * 60`语句的词法分析过程
   * `position`词素
      * 被映射成词法单元<id, 1>
         * id表示标识符
         * 1指向符号表中position对应的条目，一个标识符对应的符号表条目存放该标识符有关的信息，比如名字和类型等
   * `=`词素
      * 被映射成<=>
      * 这个词法单元不需要属性，忽略第二个分量
   * `initial`词素
      * 被映射成<id, 2>
   * `+`词素
      * 被映射成<+>
   * `rate`词素
      * 被映射成<id, 3>
   * `*`词素
      * 被映射成<*>
   * `60`词素
      * 被映射成<60>
   * 因此，最终上述赋值语句被表示成：`<id, 1> <=> <id, 2> <+> <id, 3> <*> <60>`<br>
     ![compile_phase_example](./pictures/compile_phase_example.png)

### 语法分析 - syntax analysis
* 目的：根据token-name，生成语法树
* 语法分析器使用由词法分析器生成的各个词法单元的第一个分量来创建树形的中间表示
   * 树种的每个内部结点表示一个运算，而该结点的子结点表示该运算分量

### 语义分析 - semantic analyzer
* 目的：使用语法树和符号表种的信息，检查源程序是否和语言定义的语义一致
   * 类型检查

### 中间代码生成
* 目的：生成一个明确的低级的或类机器语言的中间表示
* 中间表示的两个重要性质
   * 易于生成
   * 能够轻松地翻译为目标机器上的语言
* 三地址代码(three-address code)
   * 每个指令具有三个运算分量，每个运算分量都像一个寄存器，例如：`t3 = id2 + t2`
      * 每个三地址赋值指令的右部最多只有一个运算符
      * 编译器应该生成一个临时名字以存放一个三地址指令计算得到的值
      * 有些三地址指令的运算分量少于三个，如：`id1 = t3`

### 代码优化
编译器可将如下代码优化：
* 优化前
   ```
   t1 = inttofloat(60)
   t2 = id3 * t1
   t3 = id2 + t2
   id1 = t3
   ```
* 优化后
   ```
   t1 = id3 * 60.0
   id1 = id2 + t1
   ```

### 代码生成
* 目的：以源程序的中间表示形式作为输入，映射到目标语言
* 关键：合理分配寄存器以存放变量的值

### 将多个步骤组合成趟
* 定义：每趟读入一个输入文件并产生一个输出文件
* 前端趟：前端步骤中的词法分析、语法分析、语义分析，以及中间代码生成可以被组合在一起成为一趟
* 优化趟：代码优化可以作为一个可选的趟
* 后端趟：为特定目标机生成代码的的后端趟

### 编译器构造工具
* 语法分析器的生成器
   * 可以根据一个程序设计语言的语法描述，自动成词语法分析器
* 扫描器的生成器
   * 可以根据一个语言的语法单元的正则表达式描述，生成词法分析器
* 语法制导的翻译引擎
   * 可以生成一组用于遍历分析树并生成中间代码的例程
* 代码生成器的生成器
* 数据流分析引擎
* 编译器构造工具集
   * 提供了可用于构造编译器的不同阶段的例程的完整集合

## 构建一个编译器的相关科学
### 编译器设计和实现中的建模
* 有穷状态自动机和正则表达式
   * 描述程序的词法单位
   * 描述被编译器用来描述这些单位的算法
* 上下文无关文法
   * 描述程序设计语言的语法结构，比如嵌套的括号和控制结构
* 树形结构
   * 表示程序结构以及程序到目标代码的翻译方法

## 程序设计语言基础
### 静态和动态的区别
* 问题：编译器能够对一个程序做出哪些判定？
* 静态策略
   * 可以在编译时刻决定
* 动态策略
   * 需要在运行时刻做出决定

### 环境与状态
* 环境
   * 是一个从名字到存储位置的映射。因为变量就是指内存位置(左值)，因此环境可以说是，名字到变量的映射。
* 状态
   * 是一个从内存位置到他们的值的映射，即状态把左值映射为它们的相应右值。

环境和状态映射是动态的，但也有例外：<br>
![rvalue_lvalue](./pictures/rvalue_lvalue.png)
* 名字到位置的静态绑定与动态绑定
   * 某些声明(如全局变量)可以在编译器生成目标代码时一劳永逸地分配一个存储位置
* 从位置到值的静态绑定与动态绑定
   * 一般来说，位置到值的绑定也是动态的，因为外面无法在运行一个程序之前指出一个位置上的值。
   * 被声明的常量时一个例外，如：`#define ARRAYSIZE 1000`

### 静态作用域和块结构
一个声明的作用域有该声明在程序中出现的位置隐含地决定，C语言使用静态作用域，其作用域规则是：
* 一个C程序由一个顶层的变量和函数声明的序列组成
* 函数内部可以声明变量，变量包括局部变量和参数。每个这样的声明的作用域被限制在它们所出现的那个函数内。
* 名字x的一个顶层声明的作用域包括其后的所有程序。但是如果一个函数中也由一个x的声明，那么函数中的那些语句就不再这个顶层声明的作用域内

* 块
   * 块(block)是声明和语句的一个组合，C语言使用`{}`来界定一个块
   * ![block_scope](./pictures/block_scope.png)

### 显示访问控制
* public, private和protected
* 声明和定义
   * 声明告诉我们事物的类型
   * 定义告诉我们它们的值

### 动态作用域
如果一个作用域策略依赖于一个或多个只有在程序执行时刻才能知道的因素，它就是动态的。例如:
* C预处理器中的宏扩展
* 面向对象编程中的方法解析
   * 多态

* 静态作用域和动态作用域的类比
   * 动态规则处理时间的方式类似于静态作用域处理空间的方式
      * 静态规则让我们寻找的声明位于最内层的、包含了变量使用位置的单元中
      * 动态规则让我们寻找的声明位于最内层的、包含了变量使用时间的单元(过程调用)中

### 参数传递机制
* 值调用(call-by-value)
   * 对实在参数求值(如果是表达式)或拷贝(如果是变量)
* 引用调用(call-by-reference)
   * 实在参数的地址作为相应的形式参数的值被传递给被调用者
* 名调用
   * 实在参数以字面方式替换了被调用者的代码中的形式参数(类似宏替换)，由于有歧义，已经不再采用

## 总结
* 作用域规则：一个x的声明的作用域是一段上下文，在此上下文中对x的使用指向这个声明。如果仅仅通过阅读某个语言的程序就可以确定其作用域，那么这个语言就使用了静态作用域，或者说词法作用域。否则，这个语言就使用了动态作用域。
* 环境：名字和内存位置关联，然后再和值相关联。这个情况可以使用环境和状态来描述。其中环境把名字映射成为存储位置，而状态把位置映射到它的值。

# 一个简单的语法制导翻译器
本章的目的：通过开发一个可运行的Java程序，将具有代表性的程序设计语言语句翻译为三地址代码(一种中间表示形式)，着重阐述如下的前端模型。<br>
![front_end](./pictures/front_end.png)
* 先建立一个能够将中缀算术表达式转换为后缀表达式的语法制导翻译器。
   * 后缀表达式是一种将运算符置于运算分量之后的表示方法，如：`9-5+2`的后缀形式是`95-2+`
