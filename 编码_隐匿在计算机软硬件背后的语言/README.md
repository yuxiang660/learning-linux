# 第一章 至亲密友
编码不是加密，编码是交流，是传递信息的方式。
![morse_code](./pictures/morse_code.png)

# 第十章 逻辑与开关
## 逻辑符号
* 交集：$\bigcap$
* 并集：$\bigcup$

## 语言与逻辑公式
* 例如，所有人都必有一死；苏格拉底是人。
   * P表示所有人的集合
   * M表示必有一死的事物
   * S表示苏格拉底的集合
* 所有人都必有一死可表示为：P * M = P
* 苏格拉底是人可表示为：S * P = S
* 推论，S * (P * M) = S。根据结合律可表示为：(S * P) * M = S --> S * M = S。因此可推导出苏格拉底必有一死。如果推出的公式是：S * M = M，则表示苏格拉底会死，但是其他任何事物都是不死的。

## 布尔代数与传统代数的区别
最大的区别是，布尔代数存在加法分配律：
* W + (B * F) = (W + B) * (W + F)

# 第14章 反馈与触发器
触发器可实现电路的记忆功能，下面是带电平触发器的8位加法器，可实现一连串数字的连续加法：
![Adder](./pictures/adder.png)

分频器可由边沿触发器实现：
![divider](./pictures/divider.png)

# 第16章 存储器组织
## 随机访问存储器RAM
![RAM](./pictures/RAM.png)
由D触发器构成，时钟端由地址位控制，数据端的数据是否能起作用由地址位决定。简化后，结构如下图：
![RAM2](./pictures/RAM2.png)
上图所示的电路之所以能够被称为储存器是因为它可以保存信息。它不仅可以在每个锁存器中存储新的数据，也可以检测每个锁存器都存储了什么数据。可以随机访问存储器，读写都很自由。通过排列组合后，可构成下图复杂的RAM阵列：
![RAM3](./pictures/RAM3.png)

# 第17章 自动操作
如何优化上面的加法器，使其可以自动化工作，而无需人工一步一步输入。这里巧妙地利用了RAM的存储特点，以RAM为媒介，使输入和输出都以RAM的基础，而不是人的动作。另外通过将数据和操作分开，达到自动化不同行为，而不是单一的动作。
## 第一版累加器
![accumulator](./pictures/accumulator.png)
数据与代码指令操作的关系：
![data_code](./pictures/data_code.png)

## 第二版累加器
如何改进代码段与数据段，使其更加灵活？
![data_code2](./pictures/data_code2.png)
实现上图设计的关键是把代码RAM阵列的数据输出到3个8位锁存器中。每个锁存器保存该3字节指令的一个字节。第一个锁存器保存指令代码本身，第二个锁存器保存地址的高字节，第三个锁存器保存地址的低字节。第二个和第三个锁存器的输出构成了数据RAM阵列的16位地址。
![accumulator2](./pictures/accumulator2.png)
* 取指令(instruction fetch)
   * 从存储器取出指令的过程称为取指令。
* 执行指令(execute)
   * 机器相应指令码做一系列操作的过程称为执行指令。

## 第三版累加器
通过选择器将两个RAM并成一个RAM。
![accumulator3](./pictures/accumulator3.png)
![data_code3](./pictures/data_code3.png)

## 第四版累加器
为了实现Jump指令，修改上面的累加器。只有当指令代码为Jump指令时，才确保16位计数器的置位信号位1。
![accumulator4](./pictures/accumulator4.png)

## 总结
一台数字计算机主要由4部分构成：处理器(processor)、存储器(memory)，至少一个输入(input)设备和一个输出(output)设备。
### 机器码
能够被处理器相应的操作码，为了便于记忆。
* 把1003h地址的字节加载到累加器
   * `LOD A, [1003h]`。位于指令右侧的A和[1003h]被称为参数，它们时这个Load指令的操作对象。参数由两部分组成，左边的操作数称为目标(destination)操作数(A代表累加器)，右边的操作数称为源(source)操作数。
* 如果零标志位不是1则调转到0000h地址处
   * `JNZ 0000h`, 注意这里没有方括号，因为跳转指令要转移到的地址时0000h，而不是保存于0000h地址的值，即0000h地址就是跳转指令的操作数。

# 第21章 总线
总线是数字信号的集合，而这些信号被提供给计算机上的每块电路板。通常把信号划分为如下四类:
* 地址信号
   * 用来对RAM进行寻址操作，也可对其他设备进行寻址操作
* 数据输出信号
   * 由处理器产生，用来把数据写入到RAM或者其他设备
* 数据输入信号
   * 由处理器读取
* 控制信号
   * 控制信号可以产生于处理器，也可以由与处理器通信的其他设备产生。

## 2102存储芯片如何与16位总线协同工作？
* 2102存储芯片容量为**1024-Bit**
![2102](./pictures/2102.png)
* 8位微处理器，例如8080、6800，有16位地址，可用来寻址64KB的存储空间(等于16 * 4 * 8 bit)。那么应该如何组织2102存储芯片用于处理器的16位地址寻址呢？
![address](./pictures/address.png)
   * 寻址RAM
      * 十位信号A9~A0用于寻址八块2102存储芯片阵列，这是一个1024*8位的RAM阵列，或者说容量为1KB的RAM。
      ![1024_8](./pictures/1024_8.png)
   * 选择存储体
      * A11~A10两位用于从4KB存储体（bank）中选择一个1KB存储芯片阵列。4KB存储体是用32个2102芯片组成的，为了存储完整的字节，而连接在一起的芯片的集合。
   * A12~A15确定那些地址申请用这块存储器班.微处理器整个存储空间的大小是64KB，被划分成16个不同的区域，每个区域大小是4KB，我们设计的4KB存储器板占用了其中一个区域。
* 如何让存储板响应存储空间A000h~AFFFh？
![choose_bank](./pictures/choose_bank.png)
* 如何为四个存储体(1KB)产生片选信号？
通过一个2-4译码器，从4个存储体中选择一个：
![choose_bank_1KB](./pictures/choose_bank_1KB.png)
* 如何从四个存储体(1KB)中选择争取的数据输出信号？
在前面，我们通过选择器从多个输出中选择某个正确的输出，这里可以不需要这么做，为什么？<br>
因为2102芯片的数据输出信号是三态(tri-state)的，也就是说，除了逻辑0和逻辑1之外，数据输出信号还有第三种状态。这是一种真空态，就像芯片的引脚上什么也没连一样。当片选信号为1时，2102芯片的数据输出信号就会进入这种状态。这样一来，我们就可以把4个存储体相应的数据输出信号直接连接在一起，并且可以把8个输出复用作为总线的8个数据输入信号。
## memory和storage的区别
memory(内存)仅仅表示半导体随机访问存储器(易失性的存储设备，如SRAM, DRAM(需要刷新))；storage(存储器)用来指定任何的存储设备，通常包括软盘、硬盘和磁带。
* 与处理器的关系<br>
当微处理器发出一个地址信号，通常时寻址随机访问存储器，而非磁介质存储器。微处理器不能直接从磁盘读取数据，需要将所需的数据从磁盘调入内存(随机访问存储器)，然后它才能对其访问。