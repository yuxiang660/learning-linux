# 序
《计算机程序的构造和解释》读书笔记

* 本书中三类需要关注的对象：
    * 人的大脑
    * 计算机程序的集合
    * 计算机本身

## 环境搭建：VSCode + Racket
* 参考文档
    * https://zhuanlan.zhihu.com/p/34313034
    * https://chee5e.space/sicp-vscode-setup/
    * https://docs.racket-lang.org/sicp-manual/Installation.html
* 安装Racket
    ```sh
    sudo add-apt-repository ppa:plt/racket -y
    sudo apt-get install racket -y
    ```
    * 安装过程需要一定时间，完成后可打开如下图形界面：
    ![drRacket](./pictures/drRacket.png)
    * 安装完成后检查`racket`和`raco`命令是否能在命令行中正确执行
* 在VSCode中安装Magic Racket插件，并安装racket-langserver
    * `raco pkg install racket-langserver`
* 执行[hello程序](./code/hello/Makefile)
* 通过drRacket图形界面，安装 SICP package，以支持`#lang sicp`
    * 参考：https://docs.racket-lang.org/sicp-manual/Installation.html


# 构造过程抽象
* 心智活动的三个方面
    * 组合
        * 简单认识组合为一个复合认识
    * 类比
        * 将两个认识放在一起对照，得到相互关系的认识
    * 抽象
        * 将有关认识与其他认识隔离

## 程序设计的基本元素
为了将简单的认识组合起来形成更复杂的认识，每种语言都提供了三种机制：
* 基本表达式
    * 用于表示语言所关心的最简单的个体
* 组合的方法
    * 通过它们可以从较简单的东西出发构造出复合的元素
* 抽象的方法
    * 通过它们可以为复合对象命名，并将它们当作单元去操作

程序设计中，需要处理两类要素：
* 数据
    * 是一种我们希望去操作的“东西”
* 过程
    * 是有关操作这些数据的规则的描述

### 表达式
前缀表达式的有点：
* 适用于可能带有任意个实参的过程
* 可以直接扩充，允许出现组合式嵌套的情况

### 命名和环境
命名提供了一种通过名字去使用计算对象的方式，名字标识符称为变量。

### 组合式求值
要求值一个组合式，需要做两件事情：
* 求值该组合式的各个子表达式
* 将运算符的值应用于其他运算对象的值

对于基本表达式(数、内部运算符或者其它名字)，按如下规则处理：
* 数的值就是它们所表示的数值
* 内部运算符的值就是能完成相应操作的机器指令
* 其他名字的值就是在环境中关联于这个名字的那个对象

### 复合过程
以下元素是程序设计语言里必然会出现的：
* 数和算术运算是基本的数据和过程
* 组合式的嵌套提供了一种组织起多个操作的方法
* 定义是一种受限的抽象手段，它为名字关联相应的值

复合过程的使用方式与基本过程完全一样，用户无法分辨其是直接做在解释器里，还是被定义为一个复合过程。

### 过程应用的代换模型
过程应用的计算过程是：将复合过程应用于实际参数，就是将过程体中的每个形参用相应的实参取代后，对这一过程体求值。这一过程称为代换模型。需要强调的是：代换模型只用于帮助理解过程调用，解释器实际工作模式可能不同。

* 应用序
    * 先求值参数而后应用
    * Lisp采用应用序，这样做能避免对于表达式的重复求值
* 正则序
    * 完全展开后归约

### 条件表达式和谓词
根据检测的结果去确定接下来的不同操作。

* if表达式
    * `(if <predicate> <consequent> <alternative>)`
    * 在求值一个if表达式时，解释器从求值其`<predicate>`部分开始，如果`<predicate>`得到真值，解释器就去求值`<consequent>`并返回其值，否则它就去求值`<alternative>`并返回其值。
        * 解释器会在`<consequent>`和`<alternative>`中选择一个执行，这点非常重要，在练习1.6中，普通函数`new-if`会按应用序同时求值`<consequent>`和`<alternative>`，从而导致栈溢出

### 实例：采用牛顿法求平方根
函数与过程之间的矛盾在于：
* 函数是在描述一件事情的特征，是说明性的知识(是什么)，如：√x=那样的y，使得y≧0且y²=x
* 过程是描述如何去做这件事情，是行动性的知识(怎么做)，如：求√x的值

牛顿法求平方根的Lisp表示，求`x`的平方根`guess`：
```c
// 定义sqrt-iter，用牛顿法求x的平方法，初始猜测值为guess
(define (sqrt-iter guess x)
    (if (good-enough? guess x)
        guess
        (sqrt-iter (improve guess x)
                    x
        )
    )
)

// 定义improve，求比guess更精确的x平方根的猜测值
(define (improve guess x)
    average guess (/ x guess)
)

// 定义average，求x,y的平均值
(define (average x y)
    (/ (+ x y) 2)
)

// 定义good-enough?，判断guess是否在x平方根的误差范围
(define (good-enough? guess x)
    (< (abs (- (square guess) x)) 0.001)
)

// 以1作为所有数的初始猜测值
(define (sqrt x)
    (sqrt-iter 1.0 x)
)
```

### 过程作为黑箱抽象
* 局部名
* 内部定义和块结构

## 过程与它们所产生的计算
### 线性的递归和迭代
计算阶乘的两种方式：
* 递归
    * n * (n-1)!
    * ![6!_recur](./pictures/6!_recur.png)
    * 先逐步展开，后收缩
* 迭代
    * (1 * 1）* 2 * 3 ...
    * ![6!_iter](./pictures/6!_iter.png)
    * 没有增长或收缩
    * 状态可以用固定数目的状态变量描述的计算过程
    * 存在一套固定的规则，描述了计算过程在一个状态到下一状态转换时，这些变量的更新方式

递归和迭代对比：
* 迭代在计算过程中的任何一点，状态变量都提供了完整的描述，如果想要重新唤起一个停止的计算，只需要为解释器提供有关状态变量的值即可
* 但是对于递归计算而言，还存在一些“隐含”信息，它们并未保存在程序变量里，而是由解释器维持着，指明了在所推迟的运算所形成的链条里的漫游中， 这一计算过程处在何处。这个链条越长，需要保存的信息就越多


