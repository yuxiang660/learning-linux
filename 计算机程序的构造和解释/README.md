# 序
《计算机程序的构造和解释》读书笔记

* 本书中三类需要关注的对象：
    * 人的大脑
    * 计算机程序的集合
    * 计算机本身

## 环境搭建：VSCode + Racket
* 参考文档
    * https://zhuanlan.zhihu.com/p/34313034
    * https://chee5e.space/sicp-vscode-setup/
    * https://docs.racket-lang.org/sicp-manual/Installation.html
* 安装Racket
    ```sh
    sudo add-apt-repository ppa:plt/racket -y
    sudo apt-get install racket -y
    ```
    * 安装过程需要一定时间，完成后可打开如下图形界面：
    ![drRacket](./pictures/drRacket.png)
    * 安装完成后检查`racket`和`raco`命令是否能在命令行中正确执行
* 在VSCode中安装Magic Racket插件，并安装racket-langserver
    * `raco pkg install racket-langserver`
* 执行[hello程序](./code/hello/Makefile)
* 通过drRacket图形界面，安装 SICP package，以支持`#lang sicp`
    * 参考：https://docs.racket-lang.org/sicp-manual/Installation.html


# 构造过程抽象
* 心智活动的三个方面
    * 组合
        * 简单认识组合为一个复合认识
    * 类比
        * 将两个认识放在一起对照，得到相互关系的认识
    * 抽象
        * 将有关认识与其他认识隔离

## 程序设计的基本元素
为了将简单的认识组合起来形成更复杂的认识，每种语言都提供了三种机制：
* 基本表达式
    * 用于表示语言所关心的最简单的个体
* 组合的方法
    * 通过它们可以从较简单的东西出发构造出复合的元素
* 抽象的方法
    * 通过它们可以为复合对象命名，并将它们当作单元去操作

程序设计中，需要处理两类要素：
* 数据
    * 是一种我们希望去操作的“东西”
* 过程
    * 是有关操作这些数据的规则的描述

### 表达式
前缀表达式的有点：
* 适用于可能带有任意个实参的过程
* 可以直接扩充，允许出现组合式嵌套的情况

### 命名和环境
命名提供了一种通过名字去使用计算对象的方式，名字标识符称为变量。

### 组合式求值
要求值一个组合式，需要做两件事情：
* 求值该组合式的各个子表达式
* 将运算符的值应用于其他运算对象的值

对于基本表达式(数、内部运算符或者其它名字)，按如下规则处理：
* 数的值就是它们所表示的数值
* 内部运算符的值就是能完成相应操作的机器指令
* 其他名字的值就是在环境中关联于这个名字的那个对象

### 复合过程
以下元素是程序设计语言里必然会出现的：
* 数和算术运算是基本的数据和过程
* 组合式的嵌套提供了一种组织起多个操作的方法
* 定义是一种受限的抽象手段，它为名字关联相应的值

复合过程的使用方式与基本过程完全一样，用户无法分辨其是直接做在解释器里，还是被定义为一个复合过程。

### 过程应用的代换模型
过程应用的计算过程是：将复合过程应用于实际参数，就是将过程体中的每个形参用相应的实参取代后，对这一过程体求值。这一过程称为代换模型。需要强调的是：代换模型只用于帮助理解过程调用，解释器实际工作模式可能不同。

* 应用序
    * 先求值参数而后应用
    * Lisp采用应用序，这样做能避免对于表达式的重复求值
* 正则序
    * 完全展开后归约

### 条件表达式和谓词
根据检测的结果去确定接下来的不同操作

### 实例：采用牛顿法求平方根
函数与过程之间的矛盾在于：
* 函数是在描述一件事情的特征，是说明性的知识(是什么)，如：√x=那样的y，使得y≧0且y²=x
* 过程是描述如何去做这件事情，是行动性的知识(怎么做)，如：求√x的值

牛顿法求平方根的Lisp表示，求`x`的平方根`guess`：
```sicp
(define (sqrt-iter guess x)
    (if (good-enough? guess x)
        guess
        (sqrt-iter (improve guess x)
                    x
        )
    )
)

(define (improve guess x)
    average guess (/ x guess)
)

(define (average x y)
    (/ (+ x y) 2)
)
```


