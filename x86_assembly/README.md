# 李忠《x86汇编语言：从实模式到保护模式》读书笔记

# 第2章 处理器、内存和指令

![code_in_mem](./pictures/code_in_mem.png)
从上图中，注意区分代码中的指令(代表各种操作)、立即数(操作的对象)、内存地址(操作的对象)。

## 古老的Intel 8086处理器
* 8086如何处理程序的重定位问题？
   * 由于8086访问内存时使用了分段机制，代码中的地址就是段内偏移量(相当于相对地址)，所以天然支持重定位(段：偏移)，只需要更改段的内容就可以了。
   * 8086提供了两个段，分别是代码段(Code Segment, CS)寄存器和数据段(Data Segment, DS)寄存器。
* 8086重定位举例子
   * 假如物理地址00000H(20位)开始，一直到82251H处都被其他程序占用着，而后面一致到FFFFFH的地址空间都是自由的。那么你可以从物理内存地址82251H之后的地方加载你的程序
   * 定义段地址并设置处理器的段地址CS
      * 82260H是第一个符合条件的物理地址，因为它的偏移地址是0000H，段地址就是8226H。由此可看出8086是按16字节对齐的

# 第3章 汇编语言和汇编软件
## NASM编译器
理论上只要针对Intel处理器开发的软件，底层的机器指令代码都是相同的。但是仅仅具有一致的底层机器代码还远远不够，这些代码要被处理器来一次执行，首先需要加载到内存并实施重定位。因此，软件还需要一些额外的信息来告诉操作系统，如何加载自己。因为每个操作系统都会根据自身的工作特点，定义自己所能识别的软件可执行文件格式，而缺乏通用性。

# 第4章 虚拟机的安装和使用
## 计算机的启动过程
* 计算机的加电和复位
   * 对于8086，复位将使代码段寄存器CS的内容为0xFFFF，其他所有寄存器的内容都为0x0000，包括指令指针寄存器IP
* 基本输入输出系统
   * 8086内存排布
      ![8086_cpu](./pictures/8086_cpu.png)
      * ROM占据着整个内存空间顶端的64KB，物理地址范围使0xF0000~0xFFFFF，里面固化了开机时要执行的指令
      * DRAM占据着较低端的640KB，地址范围时0x00000~0X9FFFF
      * 中间还有一部分分给了其他外围设备
   * 初始跳转
      * 8086加电复位时，它取的第一条指令位于物理地址FFFF:0000(物理地址0xFFFF0)，正好位于ROM中，哪里固化了开机时需要执行的指令。此指令时一个跳转指令，通过它改变CS和IP的内容，使处理器从ROM中的较低地址处开始取指令执行。
   * 执行ROM中的指令
      * ROM芯片中的内容包括很多部分，主要是进行硬件的诊断、检测和初始化，只针对哪些最基本的、对于使用计算机而言最重要的设备。
   * 从辅助存储设备读取指令数据
      * 当ROM-BIOS完成后，从辅助存储设备读取指令数据，然后转到哪里开始执行
* 一切从主引导扇区开始
   * 如果计算机的设置从硬盘启动，那么，ROM-BIOS将读取硬盘主引导扇区(0面0道1扇区)的内容，将它加载道内存地址0000:7c00(物理地址0x07c00)，然后用一个jmp指令跳转道那里接着执行。
