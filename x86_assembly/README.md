# 李忠《x86汇编语言：从实模式到保护模式》读书笔记

# 第2章 处理器、内存和指令

![code_in_mem](./pictures/code_in_mem.png)
从上图中，注意区分代码中的指令(代表各种操作)、立即数(操作的对象)、内存地址(操作的对象)。

## 古老的Intel 8086处理器
* 8086如何处理程序的重定位问题？
   * 由于8086访问内存时使用了分段机制，代码中的地址就是段内偏移量(相当于相对地址)，所以天然支持重定位(段：偏移)，只需要更改段的内容就可以了。
   * 8086提供了两个段，分别是代码段(Code Segment, CS)寄存器和数据段(Data Segment, DS)寄存器。
* 8086重定位举例子
   * 假如物理地址00000H(20位)开始，一直到82251H处都被其他程序占用着，而后面一致到FFFFFH的地址空间都是自由的。那么你可以从物理内存地址82251H之后的地方加载你的程序
   * 定义段地址并设置处理器的段地址CS
      * 82260H是第一个符合条件的物理地址，因为它的偏移地址是0000H，段地址就是8226H。由此可看出8086是按16字节对齐的

# 第3章 汇编语言和汇编软件
## NASM编译器
理论上只要针对Intel处理器开发的软件，底层的机器指令代码都是相同的。但是仅仅具有一致的底层机器代码还远远不够，这些代码要被处理器来一次执行，首先需要加载到内存并实施重定位。因此，软件还需要一些额外的信息来告诉操作系统，如何加载自己。因为每个操作系统都会根据自身的工作特点，定义自己所能识别的软件可执行文件格式，而缺乏通用性。

# 第4章 虚拟机的安装和使用
## 计算机的启动过程
* 计算机的加电和复位
   * 对于8086，复位将使代码段寄存器CS的内容为0xFFFF，其他所有寄存器的内容都为0x0000，包括指令指针寄存器IP
* 基本输入输出系统
   * 8086内存排布
      ![8086_cpu](./pictures/8086_cpu.png)
      * ROM占据着整个内存空间顶端的64KB，物理地址范围使0xF0000~0xFFFFF，里面固化了开机时要执行的指令
      * DRAM占据着较低端的640KB，地址范围时0x00000~0X9FFFF
      * 中间还有一部分分给了其他外围设备
   * 初始跳转
      * 8086加电复位时，它取的第一条指令位于物理地址FFFF:0000(物理地址0xFFFF0)，正好位于ROM中，哪里固化了开机时需要执行的指令。此指令时一个跳转指令，通过它改变CS和IP的内容，使处理器从ROM中的较低地址处开始取指令执行。
   * 执行ROM中的指令
      * ROM芯片中的内容包括很多部分，主要是进行硬件的诊断、检测和初始化，只针对哪些最基本的、对于使用计算机而言最重要的设备。
   * 从辅助存储设备读取指令数据
      * 当ROM-BIOS完成后，从辅助存储设备读取指令数据，然后转到哪里开始执行
* 一切从主引导扇区开始
   * 如果计算机的设置从硬盘启动，那么，ROM-BIOS将读取硬盘主引导扇区(0面0道1扇区)的内容，将它加载道内存地址0000:7c00(物理地址0x07c00)，然后用一个jmp指令跳转道那里接着执行。

# 第5章 编写主引导扇区代码
一段精心编写的主引导扇区代码将检测用来启动计算机的操作系统，并计算出它所在的硬盘位置。然后，它把操作系统的自举代码加载到内存，也用jmp指令跳转到那里继续执行，直到操作系统完全启动。

## 在屏幕上显示文字
[例子print_mbr](./code/mbr/mbr.asm)是在屏幕上打印“Label offset:”加上一个数字，这个数字是“number”的汇编地址。
### 显卡和显存
显卡的工作是周期性地从显存中提取比特位，并把它们按顺序显示在屏幕上<br>
![video_mem](./pictures/video_mem.png)
   * 如果比特是“0”，则像素保持原来的状态不变，因为屏幕本来就是黑的
   * 如果比特是“1”，则点亮对应的像素
   * 如果是黑白色，一个比特位就够了。如果是真彩色，需要24个比特位，可显示2^24中颜色
文本模式和图形模式是显卡的两种基本工作模式<br>
![video_char](./pictures/video_char.png)
为了方便访问显存，设计人员将显存映射到处理器可以直接访问的地址空间<br>
   ![mem_video](./pictures/mem_video.png)
   * 例如8086可以访问1MB内存，其中，0x00000~0x9FFFF属于常规内存，有内存条提供；0xF0000~0XFFFFF有主板上的一个芯片提供，即ROM-BIOS。
   * 这样一来，中间还有一个320KB的空间，即0xA0000~0xEFFF。这段空间由特定的外围设备来提供，其中就包括显卡。
   * 加电自检之后，显卡会把自己初始化到文本模式，0xB8000~BFFFF这段物理空间留给显卡
### 初始化段寄存器
考虑到文本模式下显存的起始物理地址是0xB800，所以初始CS段寄存器为0xB800，偏移地址从0x0000延伸到0xFFFF。
访问内存可以使用段寄存器DS，也可以使用ES(extra segment)。
为了往显存中写数据，将ES寄存器设置为0xB800，可参考[mbr.asm](./code/mbr/mbr.asm)最开始两行
### 显存的访问和ASCII代码
屏幕上的每个字符对应着显存中的两个连续字节，前一个是字符的ASCII代码，后面是字符的显示属性，包括字符颜色和底色。如下图，字符"H"的ASCII代码是0x48，其显示属性是0x07；字符“e”的ASCII代码是0x65，其显示属性是0x07<br>
![video_code](./pictures/video_code.png)
低4位是前景色，高4位是背景色。K是闪烁位(1是闪烁)，I是亮度位(1是高亮)<br>
![video_rgb](./pictures/video_rgb.png)
下面的代码是在往显存中写入数据：
```nasm
;以下显示字符串"Label offset:"
mov byte [es:0x00],'L'
mov byte [es:0x01],0x07
mov byte [es:0x02],'a'
mov byte [es:0x03],0x07
...
```
其中关键字“byte”用来修饰目的操作数，指出本次传送是以字节的方式进行的。单次mov的传送宽度可以由目的操作数或源操作数来判断。但是这里的目的操作数是偏移地址“es::0x00”，它即可以是字节byte，也可以是word；而源操作数也无法判断长度。因此，这里必须用“byte”或“word”加以修饰。
### 显示标号的汇编地址
汇编地址是在源程序编译期间，编译器为每条指令确定的汇编位置，也就是每条指令相对于整个程序开头的偏移量，以字节计。当编译后的程序装入物理内存后，它又是该指令在内存段内的偏移地址。
* 如何给指令标号？
   * 有三种写法，其中near关键字是伪指令表示目标依然在当前代码段内：
      * 若jump后跟物理地址(即，段地址：偏移地址)，则jump的操作码是0xEA (直接转移指令)
      * 若jump后跟汇编地址，则jump的操作码是0xE9 (相对转移指令)
   ```
   infi: jmp near infi
   ```
   ```
   infi jmp near infi
   ```
   infi:
      jmp near infi
   ```
   ```
### 如何显示十进制数字
标号`number`位于[源程序](./code/mbr/mbr.asm)第100行。由于标号可用用来代表指令的汇编地址，所以可用通过`mov ax,number`将汇编地址传递到寄存器AX。
传送到寄存器AX的值是在源程序编译时确定的，在编译阶段，编译器会将标号number转换成立即数。编译后，number的汇编地址是0x012E，因此，这条上面的语句其实就是`mov ax,0x012E`。
* 在程序中声明并初始化数据，四种数据声明伪指令，数据不能超过伪指令所指示的大小
   * DB指令来声明字节Byte
   * DW用于声明字数据Word
   * DD用于声明双字Double Word
   * DQ用于声明四字Quad Word
* 分解数的各个位数
   * 程序第46行，div指令用DX:AX作为被除数，除以BX的内容，执行后得到的商在AX中，余数在DX中。因为除数是10，余数自然比10小，可从DL中取得
   * 第47行中，偏移地址并非理论上的“number+0x00”，而是0x7c00+number+0x00。这个0x7c00是从那里来的？
      * 标号number所代表的汇编地址，其数值是在源程序编译阶段确定的，而且是相对于整个程序的开头，从0开始计算的。主引导扇区代码是被加载到0x0000:0x7C00处，而非0x0000:0000。
      ![mbr_mem](./pictures/mbr_mem.png)
### 显示分解出来的各个位数
经过上面5次除法操作，寄存器AX中的数分解成单独的数位，并存到DS指向的位置。为了将数字显示到屏幕上，从DS指向的数据段依次取出这些数位，并写入ES指向的附加段(显示缓冲区)。源程序第71行，将AL中的内容加上0x30，得到该数字对应的ASCII代码。

### 使程序进入无限循环状态
为了避免发生问题，源程序第98行，安排了一个无限循环：`infi: jmp near infi`。jmp是转移指令，用于使处理器脱离当前的执行序列，转移到指定的地方执行。关键字near表示目标位置依然在当前代码段内。
* 为什么不写成`jmp near 0x7c00+infi`?
   * 若jump后跟物理地址(即，段地址：偏移地址)，则jump的操作码是0xEA (直接转移指令)
   * 若jump后跟汇编地址，则jump的操作码是0xE9 (相对转移指令)

### 加载和运行主引导扇区代码
通过[Makefile](./code/mbr/Makefile)中的命令，可用生成启动镜像a.img，可用于bochs或者qemu虚拟机启动。`make && make qemu`运行结果如下：<br>
![mbr_result](./pictures/mbr_result.png)

# 第6章 相同的功能，不同的代码
本章介绍三种不同的程序流程控制方法(参见[例子](./code/mbr2))，实现上一章(参见[例子](./code/mbr))一样的程序功能。

## 跳过非指令的数据区
```nasm
6:   jmp near start
7:
8:   mytext db 'L',0x07,'a',0x07,'b',0x07,'e',0x07,'l',0x07,' ',0x07,'o',0x07,\
9:            'f',0x07,'f',0x07,'s',0x07,'e',0x07,'t',0x07,':',0x07
10:  number db 0,0,0,0,0
```
* 跳转指令`jmp near start`
   * 源程序第8行和第10行声明了非指令的数据，通过第6行的跳转指令，越过这些不可执行的数据，转移到后面的代码出执行。
* 在数据声明中使用字面值
   * 源程序第8行和第9行，将字面值用数据声明，便于修改

## 段之间的批量数据传送
两个指令可用于把数据从内存中的一个地方批量地传动到另一个地方。原始数据串的地址由DS:SI指定，要传送的目的地址由ES:DI指定，传送的字节数由CX指定。
* `rep movsb` - 以字节为单位
* `rep movsw` - 以字为单位

## 使用循环分解数位
循环依赖的使循环指令loop，可参见程序的第37行，处理器在执行loop指令时会做两件事：
* 将寄存器CX的内容减一
* 如果CX的内容不为零，转到指定的位置处执行，否则顺序执行后面的指令

对比存储数位的两种不同形式：
* 通过BX寄存器，相对地址存储
```nasm
  digit: 
         xor dx,dx
         div si
         mov [bx],dl                   ;保存数位
         inc bx 
         loop digit
```
* 以绝对地址存储，需要加上数据段地址0x7c00
   * 通过反汇编可看出，`mov [0x7c00+number+0x01],dl`是内存的绝对地址
```nasm
         ;求个位上的数字
         mov dx,0
         div bx                        ;被除数是dx:ax，除数是bx，执行后，余数存到dx中，商存到ax中
         mov [0x7c00+number+0x00],dl   ;保存个位上的数字

         ;求十位上的数字
         xor dx,dx
         div bx
         mov [0x7c00+number+0x01],dl   ;保存十位上的数字
```

## 数位的显示
```nasm
   show:
         mov al,[bx+si]
         add al,0x30
         mov ah,0x04
         mov [es:di],ax
         add di,2
         dec si
         jns show
```
`jns show`的意思是，如果未设置符号位，则转移到“show”所在的位置处执行。标志寄存器里有符号位SF，dec指令会影响到该位。如果计算结果的最高位不是0，则SF置1。因此，`dec si`指令在SI的内容变负的时候，循环退出。

## NASM编译器的$和$$标记
* $是当前行的汇编地址
* $$是当前汇编节的其实汇编地址，如果没定义节或段，就默认自成一个汇编段，起始汇编地址是0
程序第53行`jmp near $`是一个无限循环，相当于`infi: jmp near infi`。

## 运行结果
![qemu_result2](./pictures/qemu_result2.png)

## 堆栈
不同与前面的例子，![例子mbr3](./code/mbr3/mbr.asm)用堆栈的方法将寄存器中的数字显示在屏幕上。

和代码段、数据段一样，堆栈被定义成一个内存段，有段寄存器SS指向。压栈和出栈只能在一端进行，所以需要用堆栈指针寄存器SP来指示下一个数据应当压入堆栈内的什么位置，或数据从那里出栈。

此例子的内存排布如下：
![mbr3_mem](./pictures/mbr3_mem.png)
* 总内存1MB，物理地址0x00000~0xFFFFF
* 假定数据段长度是64KB，物理地址0x07C00~0x17BFF，对应逻辑地址是：0x07C0:0x0000~0x07C0:0xFFFF
* 代码段和堆栈段是同一段，0x00000~0x0FFFF

# 第7章 8086处理器
## 8086寄存器类型
![registers_16bit](./pictures/registers_16bit.png)
* AX寄存器
   * 累加器Accumulator，与它有关的指令还会做指令长度上的优化
* BX寄存器
   * 基址寄存器Base Address，提供偏移地址
* CX寄存器
   * 计数器Counter
* DX寄存器
   * 数据寄存器Data，除了作为通用寄存器使用外，还专门用于和外设之间进行数据传送
* SI寄存器
   * 源索引寄存器Source Index
* DI寄存器
   * 目标索引寄存器Destination Index，用于数据传送操作

## 8086标志位
* 符号标志位SF - Sign Flag
* 奇偶标志位PF
   * 如果运算结果低8位中，由偶数个为1的比特，则PF=1
* 进位标志位CF
   * 如果最高位由向前进位或借位的情况发生，则CF=1
* 溢出标志OF
   * 如果结果超出了目标操作数所能容纳的范围，OF=1
### 现有指令对标志位的影响
![ins_flag](./pictures/ins_flag.png)
### 条件转移指令
![jmp](./pictures/jmp.png)

## 8086寻址方式

8086有多种寻址方式：
* 寄存器寻址
   * 指令执行时，操作的数位于寄存器中
   * `mov ax,cx`，`inc dx`
* 立即寻址
   * 指令的操作数时一个立即数
   * `add bx,0xf000`，`mov dx,label_a`
* 内存寻址
   * 直接寻址
      * 操作数是一个偏移地址，而且给出了该偏移地址的具体数值
      * `mov ax,[0x5c0f]` - 处理器将数据段寄存器DS的内容左移4位，加上0x5c0f，形成20位物理地址
      * `add word [0x0230],0x5000`
      * `xor byte [es:label_b],0x05`
   * 基址寻址
      * 指令的地址部分使用基址寄存器BX或BP来提供偏移地址
      * `buffer dw 0x20,0x100,0x0f,0x300,0xff00`
      * `mov [bx],dx` - 目的操作数采用了基址寻址，处理器将数据段寄存器DS的内容左移4位，加上基址寄存器BX中的内容
      * `add byte [bx],0x55`
      * `mov ax,[bp]` - 处理器将栈段寄存器SS的内容左移4位，加上寄存器BP的内容，形成20位的物理地址
   * 变址寻址
      * 使用变址寄存器SI和DI
      * `mov [si],dx` - 处理器将数据段寄存器DS的内容左移4位，加上变址寄存器SI中的内容
      * `and byte [di+label_a],0x80`
   * 基址变址寻址
      * 使用基址变址的操作数可用使用一个基址寄存器(BX或者BP)，外加一个变址寄存器(SI或者DI)
      * `mov ax,[bx+si]` - 处理器把数据段寄存器DS的内容左移4位，加上基址寄存器BX的内容，再加上变址寄存器SI的内容，通过形成了20位的物理地址
      * `add word [bx+di],0x3000`

# 第8章 硬盘和显卡的访问与控制
本章把主引导扇区改造成一个程序加载器，加载用户程序，并执行该程序。

## 用户程序的结构
### 分段、段的汇编地址和段内汇编地址
一个规范的程序，应当包括：
* 代码段
* 数据段
* 附加段
* 堆栈段

NASM如何定义段？
* `SECTION 段名称` 或者 `SEGMENT 段名称`
* 一旦定义段，后面的内容属于该段，除非又出现另一个段的定义
* NASM编译器不关心段的用途，段只用来分隔程序中的不同内容
* NASM对段的数量没有限制，一个程序可拥有不止一个代码段和数据段
* Intel处理器要求段在内存中的起始物理地址是16字节对齐的，在段定义中使用`align=`指定某个SECTION的汇编地址对齐方式

如何取得每个段的汇编起始地址？
* `section.段名称.start`

如何计算段内标号的汇编地址？
* 如果段定义中有`vstart=0`，例如[program.asm](./code/load/program.asm)中的`SECTION code_1 align=16 vstart=0`,
   * 则此段内的标号是相对与段data起始处的长度，而不是从程序头开始计算
* 如果段定义中没有`vstart=0`，例如[program.asm](./code/load/program.asm)中的`SECTION trail align=16`,
   * 则此段内的标号从整个程序开头计算，如，`program_end`标号

## 加载器是如何加载用户程序
![loader_program](./pictures/loader_program.png)
加载器必须与用户之间有一个固定的协议，比如，在用户程序内部的某个固定位置，包含一些基本的结构信息，每个用户程序都必须把自己的情况放在这里，而加载器也固定在这个位置读取。一般这个位置就是用户程序头部，例如[program.asm](./code/load/program.asm)中的`SECTION header vstart=0`段。

### 用户程序头
用户程序头一般包括下面的信息：
* 用户程序的尺寸
```nasm
program_length  dd program_end          ;程序总长度[0x00]
```
   * 以字节位单位，加载器需要根据这一信息来决定读取多少个逻辑扇区
   * 伪指令dd用于声明和初始化一个双字，即32位数据
* 应用程序的入口点，包括段地址和偏移地址
```nasm
;用户程序入口点
code_entry      dw start                ;偏移地址[0x04]
                  dd section.code_1.start ;段地址[0x06]
```
* 段重定位表
```nasm
realloc_tbl_len dw (header_end-code_1_segment)/4
                                          ;段重定位表项个数[0x0a]
;段重定位表
code_1_segment  dd section.code_1.start ;[0x0c]
code_2_segment  dd section.code_2.start ;[0x10]
data_1_segment  dd section.data_1.start ;[0x14]
data_2_segment  dd section.data_2.start ;[0x18]
stack_segment   dd section.stack.start  ;[0x1c]
```
   * 加载器需要知道每个段在用户程序内的位置

### 加载器
加载器需要加载一个用户程序，并使之开始执行，需要决定两件事情：
* 看看内存中的什么地方是空闲的，即从哪个物理内存地址开始加载用户程序
* 用户程序位于硬盘上的什么位置，它的起始逻辑扇区号是多少

[加载器例子](./code/load/mbr.asm)中，先用伪指令equ声明了以给常量。和其他伪指令db、dw、dd不同，用equ声明的数值不占用任何汇编地址，也不再运行时占用任何内存位置。
![loader_mem](./pictures/loader_mem.png)

加载器需要做以下的工作：
* 初始化工作
   * 设置栈，代码行12~14
* 加载用户程序到内存
   * 定位内存加载位置，修改DS的值，代码行16~21
   * 从磁盘扇区中读入数据，通过read_hard_disk_0调用完成
* 重定位
   * 重定位程序入口段地址
   * 重定位重定位表中的各段
* 跳转到用户程序入口函数

## I/O端口和端口访问
不可能将所有的I/O接口直接和处理器相连，设备那么多，还有些设备现在没有发明出来，将来一定会有。你怎么办？即如何扩展？
* 采用总线技术，I/O设备和总线打交道，总线再和处理器打交道，增加一层抽象

每个设备的I/O接口都抢着和处理器说明，不发生冲突都难。你怎么办？即如何解决I/O访问的冲突问题？
* 输入输出控制设备集中器(I/O Controller Hub, ICH)
![ich](./pictures/ich.png)
   * 协调各个I/O接口对处理器的访问，即南桥
   * 处理器想和某个设备说话时，ICH会接到通知，然后它负责提供相应的传输通道和其他辅助支持，并命令其他所有无关设备闭嘴

处理器通过端口(Port)来和外围设备打交道。本质上，端口就是一些寄存器，类似于处理器内部的寄存器。不同之处在于，这些叫做端口的寄存器位于I/O接口电路中。每个I/O接口都可能拥有好几个端口。

CPU如何方法各种端口和外围设备通信？
![cpu_io](./pictures/cpu_io.png)
* CPU有两种方式访问外围设备
   * 端口号映射到内存地址空间，比如显卡的访问
   * 端口时独立编址的，不和内存发生关系
      * 如上图中，M/IO#低电平时，CPU访问I/O端口；而其高电平时，访问内存
      * 以PATA/SATA接口为例，其被分配了8个端口。ICH芯片内部通常集成了两个PATA/SATA接口，分别时主硬盘接口和副硬盘接口。主硬盘接口分配的端口号是：0x1f0~0x1f7。副硬盘接口分配的端口号是0x170~0x177

独立编址访问IO设备的方式是什么？
* in指令从端口读
   * `in al,dx`或者`in ax,dx`，8位用al，16位用ax
   * `in al,0xf0`或者`in ax,0x03`，操作源是一字节立即数，只能访问0~255号端口
* out指令写端口
   * 目的操作数可用是8位立即数或寄存器DX，操作源必须是寄存器AL或者AX
   ```nasm
   out 0x37,al       ;写0x37号端口
   out 0xf5,ax       ;写0xf5号端口
   out dx,al         ;8位端口，端口号在DX中
   out dx,ax         ;16位端口，端口号在DX中
   ```

如何读取硬盘上的数据？
* 两种模式
   * CHS模式
      * 磁头号，柱面号和扇区号访问，比较原始
   * LBA28模式
      * 同一编址，从扇区0开始
      * LBA28用28比特来表示逻辑扇区号
* LBA28读取一个扇区的步骤
   * 设置访问扇区地址
      * 通过端口0x1f2设置读取扇区数
      * 通过端口0x1f3，0x1f4，0x1f5设置24位逻辑扇区号
      * 通过端口0x1f6设置LBA模式
   * 发送读命令
      * 通过端口0x1f7设置读操作
   * 等待读命令完成
      * 通过轮询端口0x1f7的第7位，等待读操作完成
   * 从数据端口读入数据到数据段
      * 通过数据端口0x1f0，读取512字节的数据到由段寄存器DS指定的数据段，偏移地址由寄存器BX指定
   * 检测错误
      * 通过0x1f1端口，可用检测最后一次执行命令的状态

## 8086有几种调用方式
8086支持四种调用方式：
* 16位相对近调用(操作码0xE8)
```nasm
call near proc_1  ;near是关键字，可用省略
call proc_1       ;标号proc_1会按照一定的规则计算，存入机器码，操作码需要能通过它正确找到调用地址
call 0x0500       ;0x0500直接存入机器码，用于计算调用地址
```
   * 相对调用：指当前call指令相对于目标过程的偏移量
      * 偏移量的计算过程是：用目标过程的汇编地址减去当前call指令的汇编地址，再减去当前call指令以字节为单位的长度(3)，例如上面的“proc_1”处的汇编地址减去本指令的汇编地址，在减去3，作为机器指令的操作数
   * 近调用：指被调用的目标过程位于当前代码段内
* 16位间接绝对近调用(操作码0xFF)
```nasm
call cx           ;目标地址在CX中，省略了关键字near
call [0x3000]
call [bx+si+0x02]
```
   * 指令中的操作数不是偏移量，而是被调用过程的真实偏移地址，故称为绝对地址
   * 只能段内调用
* 16位直接绝对远调用(操作码0x9A)
```nasm
call 0x2000:0x0030
```
   * 上面指令的机器码为`9A 30 00 00 20`，后面跟着的连个字分别是偏移地址(在前)和段地址(在后)
* 16位间接绝对远调用
```nasm
call far [0x2000]
call far [proc_1]   ;proc_1 dw 0x0102,0x2000
call far [bx]
call far [bx+si]
```
   * 必须给出被调用过程的段地址和偏移地址

## 8086有几种跳转方式
* 相对短转移(操作码0xEB)
```nasm
jmp short infinite
```
   * 只允许转移到距离当前指令-128~127字节的地方
   * short关键字不能省略
   * 编译器会检查标号infinite所代表的值，如果数值超过了一字节所能允许的数字范围，会报错
* 16位相对近转移(操作码0xE9)
```nasm
jum near infinite
jmp near 0x3000
```
   * 因为是近转移，属于段内转移，指令长度是3
   * 编译器用目标位置的汇编地址减去当前指令的汇编地址，再减去当前指令的长度(3)，保留16位的结果
* 16位间接绝对近转移
```nasm
jmp near bx
jmp near cx
jmp [jump_dest]      ;jump_dest dw 0xc000, 省略了near
jmp [bx]
jmp [bx+si]
```
   * 目标地址不是再指令中直接给出的，而是用一个16位的通用寄存器或者内存地址来间接给出的
   * 以上两条指令用BX或者CX的内容来取代指令指针寄存器IP的当前内容
* 16位直接绝对远转移(操作码是0xEA)
```nasm
jmp 0x0000:0x7c00    ;段地址：偏移地址
```
* 16位间接绝对远转移
```nasm
jmp far [jump_far]   ;jump_far dw 0x33c0,0xf000
jmp far [0x40]
```
   * 指向这条指令后，访问段寄存器DS所指向的数据段，从指令中给出的偏移地址处取出两个字，分别用来替代段寄存器CS和指令指针寄存器IF的内容

## 如何读取磁盘上的用户代码到内存
通过例子中`read_hard_disk_0`的调用栈，实现了对一个扇区的读取，其调用时的栈内存如下：
![call_stack](./pictures/call_stack.png)

将用户程序从扇区中读到`phy_base`的内存位置后，需要对用户程序重定位：
![reloc_prog](./pictures/reloc_prog.png)



