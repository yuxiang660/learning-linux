> 《深入Linux内核架构》

# 简介和概述

## 内核实现策略

两种范型：

* 微内核
    * 只有最基本的功能有内核实现，其他功能都委托给一些独立的进程，并通过明确定义的通信接口于中心内核通信
    * 缺点是各个组件之间支持复杂通信需要额外的CPU时间，在实用性方面进展甚微
* 宏内核
    * 与微内核相反，所有功能打包在一个文件
    * 缺点是如果编程时不小心，很可能会导致源代码中出现复杂的嵌套
    * 优点是性能强于微内核

## 内核组成

![linux_kernel_struct](./images/linux_kernel_struct.png)

### UNIX进程

#### 线程
* fork
* exec
* clone

#### 命名空间
每个命名空间可以包含一个特定的PID集合，或可以提供文件系统的不同视图，在某个命名空间中挂载的卷不会传播到其他命名空间中

### 地址空间与特权级别

#### 特权级别
用户状态禁止访问内核空间，进入内核的两种方法：
* 用户进程系统调用
* 异步硬件中断
    * 区别在于：中断上下文中不能访问虚拟地址空间中的用户空间部分，因为中断可能是随机发生的，与用户进程无关
    ![user_kernel_mode](./images/user_kernel_mode.png)

#### 内核线程
内核线程无权处理用户空间，与中断上下文运转的内核相比，内核线程可以进程睡眠状态，更像一个用户进程。通过`ps fax`可以查看内核线程，下面置于方括号内的都是内核线程：
    ```bash
    > ps fax
        PID TTY      STAT   TIME COMMAND
        2 ?        S      0:00 [kthreadd]
        3 ?        I<     0:00  \_ [rcu_gp]
        4 ?        I<     0:00  \_ [rcu_par_gp]
        6 ?        I<     0:00  \_ [kworker/0:0H-kblockd]
        9 ?        I<     0:00  \_ [mm_percpu_wq]
        10 ?        S      0:13  \_ [ksoftirqd/0]
        11 ?        I      2:58  \_ [rcu_sched]
    ```

#### 虚拟和物理地址空间
物理内存页经常称作**页帧**，**页**则专指虚拟地址空间中的页

### 页表
* 页表定义
    * 将虚拟地址空间映射到物理哦那估计的数据结构

#### 多级分页
* 目的
    * 为了减少页表的大小
        * 对虚拟地址空间中不需要的区域，不必创建中间页目录或页表

![multi_page](./images/multi_page.png)

* 组成
    * 全局页目录(Page Global Directory)
    * 中间页目录(Page Middle Directory)
    * 页表数组(Page Table Entry)

* 缺点
    * 多级转换，速度慢

* 加速方法
    * MMU(Memory Management Unit)，CPU中硬件
    * TLB(Translation Lookaside Buffer)，频繁转换的地址，将其缓存

#### 内存映射
* 定义
    * 将任意来源的数据传输进程的虚拟地址空间中
* 应用
    * 内核在实现设备驱动程序时，直接使用了内存映射。外设的输入/输出可以映射到虚拟地址空间的区域中。对相关内存区域的读写会由系统重定向到设备，从而大大简化了驱动程序的实现。
