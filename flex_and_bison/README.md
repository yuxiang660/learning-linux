# 序
《flex与bison》读书笔记

# Flex和Bison简介
## 我们的第一个Flex程序
```
%{
int chars = 0;
int words = 0;
int lines = 0;
%}

%%

[a-zA-Z]+   { words++; chars += strlen(yytext); }
\n          { chars++; lines++; }
.           { chars++; }

%%

main (int argc, char **argv)
{
   yylex();
   printf("%8d%8d%8d\n", lines, words, chars);
}
```
* flex程序包含三个部分(通过`%%`分割)：
   * 声明和选项设置
      * `%{`和`}%`之间的代码会被原样照抄到生成的C文件的开头部分
   * 一系列的模式和动作
      * 模式(前面不能有空格) + {需要执行的C代码}
      * 模式如果用引号引起，则告诉flex使用引号内的文本的原义，而不是把他们解释成正则表达式，如："+"代表加号
      * 在任意一个flex的动作中，变量`yytext`总是被设为指向本次匹配的输入文本
   * 会被拷贝到生成的词法分析器里面的C代码
      * 主程序，主要负责调用flex提供的词法分析例程`yylex()`

* 词法分析器在动作中返回与不返回有什么区别？
   * 不返回：`"+" { printf("PLUS\n"); }`，参加[例子](./code/calc/fb1-3.l)
   * 返回：`"+"   { return ADD; }`，参加[例子](./code/calc/fb1-4.l)
      * 如果动作有返回，词法分析器会在下一次`yylex()`调用时继续
      * 如果动作没有返回，词法分析器将会立即继续进行

## 记号编号和记号值
* 当flex词法分析器返回一个记号流时，每个记号实际上有两个组成部分
   * 记号编号
   * 记号值

## 文法与语法分析
* BNF文法
   * BNF范式时书写上下文无关文法的标准格式
   * 例如下列BNF可用于描述简单的算术表达式：
      ```
      <exp> ::= <factor>
            | <exp> + <factor>
      <factor> ::= NUMBER
            | <factor> * NUMBER
      ```
      * 每一行就是一条规则，用来说明如何创建语法分析树的分支
      * 在BNF里，`::=`被读作“是”或者“变成”，|读作“或者”
      * 规则左边的名称是语法符号(symbol)

## Bison的规则描述语言
* bison程序包含了与flex程序相同的三部分结构：
   * 声明部分
      * 包含了会被原样拷贝到目标分析程序开头的C代码
      * `%token`记号声明，以便告诉bison在语法分析程序中记号的名称
      * 任何没有声明为记号的语法符号必须出现在至少一条规则的左边
   * 规则部分
      * 分号被用来表示规则的结束
      * C的动作代码在每条规则之后用花括号括起
      * 第一条规则左边的语法符号是**语法其实符号**，整个输入必须被它匹配
      * 目标符号(冒号左边的语法符号)的值在动作中代码用`$$`代替
      * 右边语法符合的语义值依次为`$1`、`$2`，直到这条规则的结束
      * 当词法分析器返回记号时，记号值总是存储在`yyval`里
      * 如果一个规则缺少显式的动作，语法分析器将把`$1`赋予`$$`
   * C代码部分

