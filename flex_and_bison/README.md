# 序
《flex与bison》读书笔记

# Flex和Bison简介
## 我们的第一个Flex程序
```
%{
int chars = 0;
int words = 0;
int lines = 0;
%}

%%

[a-zA-Z]+   { words++; chars += strlen(yytext); }
\n          { chars++; lines++; }
.           { chars++; }

%%

main (int argc, char **argv)
{
   yylex();
   printf("%8d%8d%8d\n", lines, words, chars);
}
```
* flex程序包含三个部分(通过`%%`分割)：
   * 声明和选项设置
      * `%{`和`}%`之间的代码会被原样照抄到生成的C文件的开头部分
   * 一系列的模式和动作
      * 模式(前面不能有空格) + {需要执行的C代码}
      * 模式如果用引号引起，则告诉flex使用引号内的文本的原义，而不是把他们解释成正则表达式，如："+"代表加号
      * 在任意一个flex的动作中，变量`yytext`总是被设为指向本次匹配的输入文本
   * 会被拷贝到生成的词法分析器里面的C代码
      * 主程序，主要负责调用flex提供的词法分析例程`yylex()`

* 词法分析器在动作中返回与不返回有什么区别？
   * 不返回：`"+" { printf("PLUS\n"); }`，参加[例子](./code/calc/fb1-3.l)
   * 返回：`"+"   { return ADD; }`，参加[例子](./code/calc/fb1-4.l)
      * 如果动作有返回，词法分析器会在下一次`yylex()`调用时继续
      * 如果动作没有返回，词法分析器将会立即继续进行

## 记号编号和记号值
* 当flex词法分析器返回一个记号流时，每个记号实际上有两个组成部分
   * 记号编号
   * 记号值

## 文法与语法分析
* BNF文法
   * BNF范式时书写上下文无关文法的标准格式
   * 例如下列BNF可用于描述简单的算术表达式：
      ```
      <exp> ::= <factor>
            | <exp> + <factor>
      <factor> ::= NUMBER
            | <factor> * NUMBER
      ```
      * 每一行就是一条规则，用来说明如何创建语法分析树的分支
      * 在BNF里，`::=`被读作“是”或者“变成”，|读作“或者”
      * 规则左边的名称是语法符号(symbol)

## Bison的规则描述语言
* bison程序包含了与flex程序相同的三部分结构：
   * 声明部分
      * 包含了会被原样拷贝到目标分析程序开头的C代码
      * `%token`记号声明，以便告诉bison在语法分析程序中记号的名称
      * 任何没有声明为记号的语法符号必须出现在至少一条规则的左边
   * 规则部分
      * 分号被用来表示规则的结束
      * C的动作代码在每条规则之后用花括号括起
      * 第一条规则左边的语法符号是**语法其实符号**，整个输入必须被它匹配
      * 目标符号(冒号左边的语法符号)的值在动作中代码用`$$`代替
      * 右边语法符合的语义值依次为`$1`、`$2`，直到这条规则的结束
      * 当词法分析器返回记号时，记号值总是存储在`yyval`里
      * 如果一个规则缺少显式的动作，语法分析器将把`$1`赋予`$$`
   * C代码部分

# 使用Flex
## Flex如何处理二义性模式
* 词法分析器匹配输入时匹配尽可能多的字符串
* 如果两个模式都可以匹配的话，匹配在程序中更早出现的模式

## Flex词法分析器的输入
* 输入管理的三个层次
   * 设置yyin来读取所需文件
   * 创建并使用YY_BUFFER_STATE输入缓冲区
   * 重定义YY_INPUT

# Flex规范参考
* Flex常见变量和函数
   * https://zhuanlan.zhihu.com/p/120819122
* flex程序由三部分构成
   * 定义部分
      * 定义部分的文字块会被拷贝到`yylex()`的开始部分之前
      * 文字块通常包括规则部分代码所需要使用的变量和函数声明，也包括引入头文件的`#include`
      * 如果以`%top{`开始的话，文字块会被拷贝到生成程序的头部附近
   * 规则部分
      * 规则部分开始处的文字块将被拷贝到`yylex()`中本地变量声明之后
      * 它可以包含更多的声明和设置代码
      * 规则部分其他位置的文字块在`yylex()`中的拷贝位置并不确定，所以它只应该包含注释
   * 用户子例程
* 匹配方式
   * 当flex词法分析器运行时，它根据规则部分的模式进行匹配。每次它发现一个匹配，它指向这个模式所关联的C代码
      * 如果模式后面紧跟一个竖线而不是C代码的话，该模式使用与这个文件中下一模式相同的C代码
      * 当输入字符无法匹配任何模式时，词法分析器将任务它匹配了一个动作代码位ECHO的模式，相应地，该记号被拷贝输出

## BEGIN
* 词法分析器从状态0开始，该状态也被称为`INITIAL`
* 其他所有状态必须在定义部分通过`%s`或者`%x`行来命名
* 通过`BEGIN statename;`，可切换起始状态

## NAME
* 允许对正则表达式进行命名，然后在规则部分通过名字来引用它们
* 通过`NAME expression`，可为正则表达式expression取别名，方便规则匹配

## Flex库
* `-lfx`可链接此库，库中包含`main()`和`yywrap()`

## 合并的词法分析器
* 可以使用起始状态来合并两个词法分析器
* 通常会把合并的词法分析器与合并的语法分析器结合起来使用

## 编译词法分析器的选项
* 两种形式的选项
   * 在词法分析器的开头部分写成如`%option name`的形式
      * `%option noyywrap`
   * 写成命令行上的`--name`的形式
      * `--noyywrap`

## 可重入词法分析器
* 通过`yylex_init()`来创建词法分析器
   * 每次都会产生一个独立的词法分析器，多个词法分析器可以同时生效
* 把`yyscan_t`的地址作为参数输入
* 可以把`yyscan_t`代入任何依次`yylex()`的调用中
* 最后通过`yylex_destroy`来删除`yyscan_t`
* 参考[例子](。/code/reentrancy_pure_scanner)