# 序
此文是《编译器设计》的读书笔记

# 编译概观
编译器是一种计算机程序，负责将一种语言编写的程序转换为另一种语言编写的程序。
* 前端
   * 用于处理源语言
* 后端
   * 用于处理目标语言
* 中间形式
   * 为将前端和后端连接起来，编译器有一种形式化的结构，它用一种中间形式来表示程序，中间形式的语言很大程度上独立于源语言和目标语言
* 优化器
   * 为改进转换，编译器通常包括一个优化器，来分析并重写中间形式

## 简介
### 解释器和编译器的区别与联系
* 联系
   * 二者都要分析输入程序，并判定它是否是有效的程序
   * 二者都会建立一个内部模型，表示输入程序的结构和语义
   * 二者都要确定执行期间在何处存储值
* 区别
   * 解释器通过解释代码来产生结果，而编译器通过输入转换后可执行的目标程序来产生结果

解释器举例：
* 一些语言，如Perl、Scheme和APL，更多是用解释器实现，而不是编译器。
* 一些语言采用的转换方案，既包括编译，也包括解释。Java将源代码编译为字节码，为了减少Java应用程序的下载时间。Java应用程序是通过在对应的Java虚拟机上运行字节码来执行的。JVM是一种字节码的解释器，它通过JIT(just-in-time)编译器，将频繁适用的字节码序列转换为底层计算机的本机码。
   * 虚拟机时针对某种处理器的模拟器，它时针对该机器指令集的解释器。

### 编译器的构建
一个好的编译器运用了：
* 贪心算法(寄存器分配)
* 启发式搜索技术(表调度)
* 图算法(死代码消除)
* 动态规划(指令选择)
* 有限自动机和下推自动机(词法分析和语法分析)
* 不动点算法(数据流分析)

### 编译的基本原则
两个基本原则：
* 编译器必须保持被编译程序的语义
* 编译器必须以某种可觉察的方式改进输入程序

## 编译器结构
![compiler_struct](./pictures/compiler_struct.png)
* 前端
   * 专注于理解源语言程序
   * 前端必须将其对源程序的认识编码到某种结构中，以供后端稍后适用
   * 前端必须确保源程序是良构的，而且必须将输入的代码映射到IR
* IR
   * 编译器使用一些数据结构来表示它处理的代码，这种形式称为中间表示(Intermediate Representation，IR)
   * 中间表示IR成为了编译器对所转换代码的权威表示
   * 在编译过程中的每个点，编译器都有一个权威表示
   * 随着编译过程的进展，可以使用几种不同的IR，但在每个点上，都只有一种表示会成为权威的IR
   * 我们可以将权威IR看做编译器各个独立阶段之间所传递程序的版本
* 后端
   * 专注于将程序映射到目标机
   * 后端必须将IR程序映射到目标机的指令集和有限的资源上
   * 由于后端仅处理前端生成的IR，因此它可以认为IR不包括任何语法和语义错误

![compiler_struct_detail](./pictures/compiler_struct_detail.png)

引入IR使得可以向编译增加更多阶段。上图是典型的三阶段优化编译器结构。每个阶段内部都划分为若干趟。
* 前端由两趟或三趟组成，处理识别有效源语言程序的各种细节，并产生该程序的初始IR形式
* 中间部分包含执行不同优化的各趟处理
* 后端由若干趟处理组成，每一趟都将输入的IR程序进一步处理，使之更接近目标机的指令集

### 前端
前端根据语法和语义，判断输入代码是否是良构的。如果前端发现代码是有效的，它会以编译器的IR格式来建立该diamagnetic的一个表示，否则，它向用户回报诊断错误信息，以标识该代码的问题。

#### 检查语法
编译器必须将程序的结构与语言的定义进行比较，需要
* 一种适当的形式化定义
* 一种检测输入是否满足该定义的高效机制
* 如何继续处理无效输入的相关规划

#### 什么是词法分析器？
定义：编译器中的一趟，将字符构成的串转换为单词构成的流。

词法分析器以字符流为输入，并将其转换为已归类单词的流，已归类的单词是形如(p,s)的对，其中p是单词的词类，而s是单词的拼写。以`Compilers are engineered objects。`这个句子为例，词法分析器会将其转换为下述已归类单词的流：
```
(noun,"Compilers"),(verb,"are"),(adjective,"engineered"),(noun,"objects",(endmark,"."))
```

#### 什么是语法分析器？
定义：编译器中的一趟，判断输入流是否是源语言的一个句子。

语法正确的句子可能是无意义的。例如表达式`a <- a * 2 * b * c * d`，在语法上可能是良构的，但如果b和d是字符串，这个语句仍然可能是无效的。再如，过程调用指定的参数数目应该与过程的定义一致。

#### 什么是类型检查？
编译器中的一趟，检查输入程序中对名字的使用再类型方面是否一致。

### 中间表示
编译器前端处理的最后一个问题是生成代码的IR形式。编译器可以使用各种不同种类的IR，这取决于源语言、目标语言和编译器应用的各种特定的转换。

### 优化器
优化器分析代码的IR形式，以发现有关上下文的事实，并利用此项上下文相关知识来重写代码，使之能够以更有效的方式来得到同样的答案。大多数优化都包括两个过程：
* 分析
   * 数据流分析
      * 再编译时推断运行时值的流动
   * 相关性分析
      * 使用数论中的测试方法来推断下表表达式的可能值
* 转换
   * 使用分析的结果将代码重写为一种更高效的形式

### 后端
编译器的后端会遍历代码的IR形式，并针对目标机输出代码。对于每个IR操作，后端都会选择对应的目标机操作来实现它。后端会确定哪些值能够驻留再寄存器中，哪些值需要放置到内存中。

后端的代码生成大致分为四个阶段：
* 指令选择（instruction selection）
   * 将IR操作重写为目标机操作
      * 以表达式`a <- a * 2 * b * c * d`为例，将其表示为ILOC虚拟机的代码(某种简单的RISC机器的汇编语言)，过程如下：<br>
         ![iloc_code](./pictures/iloc_code.png)
      * 指令选择器可以利用目标机提供的特殊操作。例如，如果目标机有立即数乘法操作(multI)，编译器会将上图中`mult ra,rc -> ra`替换为`multI ra, 2 -> ra`，这样就不需要`loadI 2 > r2`的操作了，而且减少了对寄存器的使用。
* 寄存器分配
   * 在指令选择期间，编译器有意忽略目标机寄存器数目有限的事实。使用所谓机虚拟寄存器（编译器勇气表示某个值可以保存在寄存器中）。实际上，编译的前期对寄存器的要求可能高于硬件的能力，寄存器分配器必须将这些虚拟寄存器映射到实际的目标机寄存器。例如，上图经过寄存器分配器后，代码重写如下（将原来的6个寄存器变为3个）：<br>
      ![iloc_code_2](./pictures/iloc_code_2.png)
   * 这种优化可能会增加对寄存器的需求，但能够消除稍后需要发出的某些多余指令
* 指令调度
   * 指令调度器重排代码中的各个操作，试图最小化等待操作数所浪费的周期数。
   * 许多处理器都可以在长延迟操作执行期间发起新的操作，因此可以通过改变代码操作顺序，将指令序列从上图的22个周期，优化成下图的13个周期:<br>
      ![iloc_code_3](./pictures/iloc_code_3.png)
      * 上图虽然优化了执行周期，但是增加了寄存器的使用数目
* 代码生成的各组件间的交互
   * 编译中大多数真正困难的问题出现在代码生成期间。例如，指令调度移动load操作，使之远离依赖load的算术操作。这样做可以增加需要这些值的时间段，但此期间内所需的寄存器数目也会相应地增加。

# 词法分析器
词法分析器的任务是将字符流变换为输入语言的单词流。本章将介绍正则表达式，这是一种用于描述程序设计语言中的有效单词的符号表示法。由此发展出了正则表达式人工或自动生成词法分析器的形式化机制。

## 简介
词法分析器的三种不同方式：
* 表驱动词法分析器
* 直接编码的词法分析器
* 手工编码方法

## 概述
编译器的词法分析器读取由字符组成的输入流，并产生包含“单词”的输出流，每个单词都标记了其“语法范畴”，等效于英文单词的词类。

识别器：
* 可以在字符流中识别特定单词的程序

语法范畴
   * 根据单词的语法用途对单词进行的分类

微语法
   * 语言的词法结构
   * 规定了如何将字符组合为单词，以及反过来如何分开混合在一起的各个单词
   * 西方语言的微语法很简单，相邻的字母由左到右聚集在一起，形成一个单词。构建单词的算法可以查找字典判断其有效性

关键字
   * 为特定语法目的而保留的单词，不能用作标识符
   * 词法分析器会将其归类到另一个语法范畴中

## 识别单词

### 转移图(transition diagram)
![find_new](./pictures/find_new.png)

上述代码片段对每个字符执行了一次测试。右侧的转移图表示了一个识别器，每个圆圈都表示计算中的一个抽象状态。状态s0时起始状态，状态s3是接受状态(两个圈表示)。仅当输入为new时，识别器才会到达状态s3。如果不是new输入，会转移到错误状态。对于每个状态来说，各种非规定输入都将转移到错误状态。

下图是while识别器的转图:<br>
![while_state](./pictures/while_state.png)

合并多个识别器，可构建用于new/not/while的识别器，如下:<br>
![word_state](./pictures/word_state.png)

### 识别器的形式化
对于需要实现转移图的代码来说，转移图充当了这些代码的抽象。转移图还可以看做是形式化的数学对象，称为“有限自动机”，它定义了识别器的规格。形式上，有限自动机（Finite Automation）是一个五元组（S，$\sum$，$\delta$，$s_{0}$，$S_{A}$），其中各分量的含义如下：
* S是识别器中的有限状态集，以及一个错误状态Se
* $\sum$是识别器使用的有限字母表，是转移图中边的标签的合集
* $\delta$(s, c)是识别器的转移函数，将每个状态$s \in S$和每个字符$c \in \sum$的组合(s, c)映射到下一个状态。在状态$s_{i}$遇到输入字符c，FA将采用转移$s_{i} \to \delta(s_{i}, c)$
* $s_{0}$是起始状态
* $S_{A}$是接受状态

有限自动机
* 识别器的一种形式化方法，包含一个有限状态集、一个字母表、一个转移函数、一个起始状态和一个或多个接受状态。
* 识别new/not/while的FA形式化如下：<br>
   ![fa_example](./pictures/fa_example.png)

### 识别更复杂的单词
下图是一个能够识别任何数字的转移图:<br>
![fa_example2](./pictures/fa_example2.png)

如果我们允许转移图有环，即可显著地简化FA，如下图：<br>
![fa_circle](./pictures/fa_circle.png)

从实现的角度看，有环图更为复杂。我们无法将这种转移图直接转换为一组嵌套if-then-else结构。转换图中的环，产生了对循环控制流的需求。我们可以用`while`循环来实现这种控制流。我们可以使用表来高效地定义$\delta$：<br>
![state_transition_table](./pictures/state_transition_table.png)
* 从状态s0出发，在不同输入字符下的状态转移
* 从状态s1或者se出发，任意输入字符都进入错误状态se
* 从状态s2出发，循环状态变化

上述转移图的伪代码如下：
![state_transition_code](./pictures/state_transition_code.png)

在C或Java这类Algol的语言中，支配标识符名的规则在简化后可能是这样：标识符以一个字母字符开头，后接零或多个字母数字字符：<br>
![fa_identifier](./pictures/fa_identifier.png)
